# coding=utf-8

from random import Random
from wikilife_data.dao.base_dao import BaseDAO
from wikilife_utils.date_utils import DateUtils

STATUS_ENABLED = 1
STATUS_DISABLED = 0


class UserDAOException(Exception):
    pass


class UserDAO(BaseDAO):
    """
    Model:
    {
        "_id" : ObjectId("4df0063ff1f70e07ea000000"),
        "createUTC": ISODate("2012-10-15T12:00:00.000Z"),
        "auto" : Boolean,
        "userId" : "CKJG3L",
        "userName" : "vad",
        "pin" : "9999",
        "status" : 1
    }
    """

    _collection = None

    def _initialize(self):
        self._collection = self.get_db().users
        self._collection.ensure_index("userId", unique=True)
        self._collection.ensure_index("userName", unique=True)

    def get_user_by_id(self, user_id):
        user = self._collection.find_one({'userId': user_id})
        return user

    def get_user_by_user_name(self, user_name):
        user = self._collection.find_one({'userName': user_name})
        return user

    def insert_user(self, user_name, pin):
        user_id = self._generate_user_id()
        return self._insert_user(user_id, user_name, pin, False)

    def insert_autogenerated_user(self, autogenerated_pin, user_name_prefix):
        if not isinstance(autogenerated_pin, basestring) or len(autogenerated_pin) == 0:
            raise UserDAOException("Invalid autogenerated pin")

        user_id = self._generate_user_id()
        user_name = "%s%s" % (user_name_prefix, user_id)

        return self._insert_user(user_id, user_name, autogenerated_pin, True)

    def _insert_user(self, user_id, user_name, pin, auto):
        if self._collection.find_one({"userName": user_name}) != None:
            raise UserDAOException("User name not available")

        create_utc = DateUtils.get_datetime_utc()
        self._collection.insert({"createUTC": create_utc, "auto": auto, "userId": user_id, "userName": user_name, "pin": pin, "status": 1})

        return user_id

    def _generate_user_id(self):
        user = {}
        chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"
        while user != None:

            user_id = ''.join(Random().sample(chars, 6))
            user = self.get_user_by_id(user_id) or None
        return user_id

    def save_user(self, user):
        """
        Intended for updates only
        """
        self._collection.save(user)

    def delete_user(self, user_id):
        if self._collection.find_one({"userId": user_id}) == None:
            raise UserDAOException("User not found")

        self._collection.remove({"userId": user_id})

        return user_id

    def delete_user_logical(self, user_id):
        user = self._collection.find_one({"userId": user_id})

        if user == None:
            raise UserDAOException("User not found")

        user["status"] = STATUS_DISABLED
        self._collection.save(user)

        return user_id

    def count_users(self, status=STATUS_ENABLED, auto=False, create_utc_from=None, create_utc_to=None):
        where = {}
        where["status"] = status
        where["auto"] = auto
        
        if create_utc_from and create_utc_to:
            where["createUTC"] = {"$gte": create_utc_from, "$lt": create_utc_to}
        elif create_utc_from:
            where["createUTC"] = {"$gte": create_utc_from}
        elif create_utc_to:
            where["createUTC"] = {"$lt": create_utc_to}
        
        return self._collection.find(where).count()

    """
    def get_users_by_namespace(self, expression, oper=None):
        query = {}
        if oper == "not_equal":
            query = {"userName": {"$not": expression}}
        else:
            query = {"userName": expression}

        return list(self._collection.find(query))
    """